// Title: Network Letters
// Author: FAL
// Date: 28. Nov. 2017
// Made with p5.js v0.5.16
// Generated by TypeScript v2.6.1


p5.disableFriendlyErrors = true;
const IDEAL_FRAME_RATE = 60;
const UNIT_ANGLE_SPEED = 2 * Math.PI / IDEAL_FRAME_RATE;
const UNIT_SPEED = 1 / IDEAL_FRAME_RATE;
const UNIT_ACCELERATION_MAGNITUDE = UNIT_SPEED / IDEAL_FRAME_RATE;
const CANVAS_SHORT_SIDE_LENGTH = 1640; 
let currentRenderer = window;
let canvasScaleFactor = 1.5;
let nonScaledWidth;
let nonScaledHeight;
let aspectRatio;
function updateCanvasScale() {
    canvasScaleFactor = Math.min(width, height) / CANVAS_SHORT_SIDE_LENGTH;
    nonScaledWidth = width / canvasScaleFactor;
    nonScaledHeight = height / canvasScaleFactor;
    aspectRatio = width / height;
}


class NormalColorUnit {
    constructor(p5Color) {
        this.p5Color = p5Color;
    }
    stroke() {
        currentRenderer.stroke(this.p5Color);
    }
    fill() {
        currentRenderer.fill(this.p5Color);
    }
}
class NoColorUnit {
    stroke() {
        currentRenderer.noStroke();
    }
    fill() {
        currentRenderer.noFill();
    }
}
class UndefinedColorUnit {
    stroke() {
    }
    fill() {
    }
}
class AlphaColorUnit {
    constructor(c, alphaResolution = 256) {
        const array = [];
        for (let alphaFactor = 0; alphaFactor < alphaResolution; alphaFactor += 1) {
            array.push(color(red(c), green(c), blue(c), alpha(c) * alphaFactor / (alphaResolution - 1)));
        }
        this.colorArray = array;
        this.maxIndex = alphaResolution - 1;
    }
    stroke(alphaValue) {
        currentRenderer.stroke(this.getColor(alphaValue));
    }
    fill(alphaValue) {
        currentRenderer.stroke(this.getColor(alphaValue));
    }
    getColor(alphaValue) {
        return this.colorArray[alphaValue ? Math.floor(map(alphaValue, 0, 255, 0, this.maxIndex)) : this.maxIndex];
    }
}
function colorUnit(p5Color, alphaEnabled, alphaResolution) {
    if (p5Color === undefined)
        return new UndefinedColorUnit();
    if (p5Color === null)
        return new NoColorUnit();
    if (alphaEnabled)
        return new AlphaColorUnit(p5Color, alphaResolution);
    return new NormalColorUnit(p5Color);
}
class ShapeColor {
    constructor(strokeColor, fillColor, alphaEnabled, alphaResolution) {
        this.strokeColor = colorUnit(strokeColor, alphaEnabled, alphaResolution);
        this.fillColor = colorUnit(fillColor, alphaEnabled, alphaResolution);
    }
    applyColor(alphaValue) {
        this.strokeColor.stroke(alphaValue);
        this.fillColor.fill(alphaValue);
    }
}

/**
 * Calculates the squared value of the Euclidean distance between
 * two points (considering a point as a vector object).
 */
function distSq(v1, v2) {
    return sq(v2.x - v1.x) + sq(v2.y - v1.y) + sq(v2.z - v1.z);
}

function loopArray(array, callback) {
    for (let i = array.length - 1; i >= 0; i -= 1) {
        callback(array[i], i, array);
    }
}

function roundRobin(array, callback) {
    const arrayLength = array.length;
    for (let i = 0, len = arrayLength - 1; i < len; i += 1) {
        for (let k = i + 1, kLen = arrayLength; k < kLen; k += 1) {
            callback(array[i], array[k]);
        }
    }
}

function nestedLoopJoin(array, otherArray, callback) {
    for (let i = 0, len = array.length; i < len; i += 1) {
        for (let k = 0, kLen = otherArray.length; k < kLen; k += 1) {
            callback(array[i], otherArray[k]);
        }
    }
}


class ArrayWrapper {
    constructor(array = []) {
        this.array = array;
    }
    get length() {
        return this.array.length;
    }
    get(index) {
        return this.array[index];
    }
    getLast() {
        return this.array[this.array.length - 1];
    }
    push(element) {
        this.array.push(element);
    }
    pop() {
        return this.array.pop();
    }
    clear() {
        this.array.length = 0;
    }
    loop(callback) {
        loopArray(this.array, callback);
    }
    roundRobin(callback) {
        roundRobin(this.array, callback);
    }
    nestedLoopJoin(otherArray, callback) {
        nestedLoopJoin(this.array, otherArray.array, callback);
    }
}

class RectangleRegion {
    constructor(x1, y1, x2, y2) {
        this.leftPositionX = x1;
        this.topPositionY = y1;
        this.rightPositionX = x2;
        this.bottomPositionY = y2;
    }
    contains(position) {
        return (position.x >= this.leftPositionX && position.x <= this.rightPositionX &&
            position.y >= this.topPositionY && position.y <= this.bottomPositionY);
    }
    get width() {
        return this.rightPositionX - this.leftPositionX;
    }
    get height() {
        return this.bottomPositionY - this.topPositionY;
    }
    get area() {
        return this.width * this.height;
    }
}

class SteppableArray extends ArrayWrapper {
    static stepFunction(value) {
        value.step();
    }
    step() {
        this.loop(SteppableArray.stepFunction);
    }
}

class DrawableArray extends ArrayWrapper {
    static drawFunction(value) {
        value.draw();
    }
    draw() {
        this.loop(DrawableArray.drawFunction);
    }
    pushInFront(element) {
        this.array.unshift(element);
    }
}

class SpriteArray extends ArrayWrapper {
    constructor() {
        super(...arguments);
        this.draw = DrawableArray.prototype.draw;
        this.pushInFront = DrawableArray.prototype.pushInFront;
        this.step = SteppableArray.prototype.step;
    }
}


class CleanableArray extends ArrayWrapper {
    cleanFunction(value, index, array) {
        value.clean();
        if (value.isToBeRemoved) {
            array.splice(index, 1);
        }
    }
    clean() {
        this.loop(this.cleanFunction);
    }
}

class CleanableSpriteArray extends SpriteArray {
    constructor() {
        super(...arguments);
        this.cleanFunction = CleanableArray.prototype.cleanFunction;
        this.clean = CleanableArray.prototype.clean;
    }
}

function clearRenderer() {
    currentRenderer.loadPixels();
    currentRenderer.pixels.fill(0);
    currentRenderer.updatePixels();
}

function hsbColor(h, s, b, a = 255) {
    colorMode(HSB, 360, 100, 100, 255);
    const c = color(h, s, b);
    colorMode(RGB);
    return c;
}

class NaiveEdge {
    constructor(nodeA, nodeB) {
        this.nodeA = nodeA;
        this.nodeB = nodeB;
    }
    isIncidentTo(node) {
        return node === this.nodeA || node === this.nodeB;
    }

    getAdjacentNode(node) {
        if (node === this.nodeB)
            return this.nodeA;
        return this.nodeB;
    }
}
//
// ------------ Graph -----------------------------
//
/// <reference path="Edge.ts" />
class NaiveArrayGraph {
    constructor(nodes, edges) {
        this.nodes = nodes;
        this.edges = edges;
    }
    getIncidentEdges(node) {
        const incidentEdges = this.edges.array.filter((edge) => { return edge.isIncidentTo(node); });
        return new ArrayWrapper(incidentEdges);
    }
    addNode(node) {
        this.nodes.push(node);
    }
    addEdge(edge) {
        this.edges.push(edge);
    }
}

class FrameCounter {
    constructor() {
        this.count = 0;
    }
    resetCount(count = 0) {
        this.count = count;
    }
    step() {
        this.count += 1;
    }
    mod(divisor) {
        return this.count % divisor;
    }
    /**
     * Returns ratio from 0 to 1 according to current frame count and given frequency per second.
     * @param frequency {number} - frequency per second
     */
    getCycleProgressRatio(frequency) {
        return ((frequency * this.count) % IDEAL_FRAME_RATE) / IDEAL_FRAME_RATE;
    }

    sin(frequency) {
        return Math.sin(this.getCycleProgressRatio(frequency) * 2 * Math.PI);
    }
}

class TimedFrameCounter extends FrameCounter {
    constructor(on, duration = 0, completeBehavior = () => { }) {
        super();
        this.isOn = on;
        this.isCompleted = false;
        this.completeBehavior = completeBehavior;
        this.durationFrameCount = duration;
    }
    on(duration) {
        this.isOn = true;
        if (duration)
            this.durationFrameCount = duration;
    }
    off() {
        this.isOn = false;
    }
    step() {
        if (!this.isOn)
            return;
        this.count += 1;
        if (this.count > this.durationFrameCount) {
            this.isCompleted = true;
            this.isOn = false;
            this.completeBehavior();
        }
    }
    getProgressRatio() {
        if (this.durationFrameCount) {
            return Math.min(Math.max(this.count / this.durationFrameCount, 0), 1);
        }
        else
            return 0;
    }
}




class ParticleNode {
    constructor(x, y, frameCounterRef) {
        this.isToBeRemoved = false;
        this.basePosition = createVector(x, y);
        this.position = createVector();
        this.noiseTimeOffset = createVector(Math.random(), Math.random()).mult(34);
        this.noiseTime = 0;
        this.parentNetworkFrameCounter = frameCounterRef;
        this.updatePosition();
    }
    step() {
        this.updatePosition();
        this.noiseTime += 0.005;
    }
    draw() {
        currentRenderer.ellipse(this.position.x, this.position.y, ParticleNode.shapeSize, ParticleNode.shapeSize);
    }
    updatePosition() {
        this.position.set(this.basePosition);
        const shrinkRatio = sq(1 - this.parentNetworkFrameCounter.getProgressRatio(.1));
        const noiseFactor = ParticleNode.minNoiseFactor
            + shrinkRatio * (ParticleNode.maxNoiseFactor - ParticleNode.minNoiseFactor);
        this.position.add(noiseFactor * (3 * noise(this.noiseTimeOffset.x + this.noiseTime) - 1), noiseFactor * (3 * noise(this.noiseTimeOffset.y + this.noiseTime) - 1));
    }
}
ParticleNode.minNoiseFactor = 50;
ParticleNode.maxNoiseFactor = 289;
ParticleNode.shapeSize = 1.5;
class ParticleEdge extends NaiveEdge {
    constructor(nodeA, nodeB) {
        super(nodeA, nodeB);
    }
    draw() {
        currentRenderer.line(this.nodeA.position.x, this.nodeA.position.y, this.nodeB.position.x, this.nodeB.position.y);
    }
}
class ParticleNetwork extends NaiveArrayGraph {
    constructor(region) {
        super(new SpriteArray(), new DrawableArray());
        this.isToBeRemoved = false;
        this.nodeColor = new ShapeColor(null, color(0, 224));
        this.edgeColor = new ShapeColor(hsbColor(Math.random() * 200, 200, 255), undefined);
        this.frameCounter = new TimedFrameCounter(true, 4 * IDEAL_FRAME_RATE);
        const margin = 10;
			//***********
        pixelDensity(.9);
        this.graphics = createGraphics(region.width + 16 * margin, region.height + 4 * margin);
        pixelDensity(displayDensity(1.1));
        this.drawPosition = createVector(region.leftPositionX - margin, region.topPositionY - margin);
        this.graphics.translate(-this.drawPosition.x, -this.drawPosition.y);
    }
    step() {
        this.nodes.step();
        this.frameCounter.step();
    }
    clean() {
    }
    draw() {
        if (!this.frameCounter.isCompleted) {
            currentRenderer = this.graphics;
            clearRenderer();
            this.edgeColor.applyColor();
            this.edges.draw();
            this.nodeColor.applyColor();
            this.nodes.draw();
            currentRenderer = window;
        }
        image(this.graphics, this.drawPosition.x, this.drawPosition.y);
    }
}

class HiddenText {
    constructor(networkArray) {
        this.graphics = createGraphics(nonScaledWidth, nonScaledHeight);
        this.graphics.noStroke();
        this.graphics.fill(255);
        this.graphics.textAlign(LEFT, TOP);
        this.graphics.textFont('Cinzel', 550);
        this.graphics.pixelDensity(1);
        this.characterPosition = createVector(0.02 * nonScaledWidth, 2);
        this.textLeading = this.graphics.textLeading();
        this.textPosition = this.characterPosition.copy(0);
        this.regionArray = new ArrayWrapper();
        this.networkArray = networkArray;
        this.networkMap = new Map();
			//*******
        this.particleInterval = 28;
        
    }
    input(key) {
        const characterWidth = this.graphics.textWidth(key);
        if (this.characterPosition.x + characterWidth > this.graphics.width)
            this.lineBreak();
        this.setText(this.currentText + key);
        const newRegion = new RectangleRegion(this.characterPosition.x, this.characterPosition.y, this.characterPosition.x + characterWidth, this.characterPosition.y + this.textLeading);
        this.regionArray.push(newRegion);
        this.characterPosition.add(characterWidth, 0);
        this.addNetwork(newRegion);
    }
    lineBreak() {
        this.setText(this.currentText + '\n');
        this.characterPosition.set(this.textPosition.x, this.characterPosition.y + this.textLeading);
        this.regionArray.push(new RectangleRegion(this.characterPosition.x, this.characterPosition.y, this.characterPosition.x, this.characterPosition.y + this.textLeading));
    }
    backspace() {
        if (this.currentText.length === 0)
            return;
        this.setText(this.currentText.substr(0, this.currentText.length - 1));
        if (this.currentText.length === 0) {
            this.clear();
            return;
        }
        const removingArea = this.regionArray.pop();
        if (!removingArea)
            return;
        const currentLastArea = this.regionArray.getLast();
        this.characterPosition.set(currentLastArea.rightPositionX, currentLastArea.topPositionY);
        const removingNetwork = this.networkMap.get(removingArea);
        if (removingNetwork)
            removingNetwork.isToBeRemoved = true;
        this.networkMap.delete(removingArea);
    }
    clear() {
        this.setText('');
        this.regionArray.clear();
        this.characterPosition.set(this.textPosition);
        this.networkArray.loop((network) => { network.isToBeRemoved = true; });
        this.networkMap.clear();
    }
    processKeyCode() {
        if (keyCode === ENTER || keyCode === RETURN) {
            hiddentext.lineBreak();
            return;
        }
        if (keyCode === BACKSPACE) {
            hiddentext.backspace();
            return;
        }
        if (keyCode === ESCAPE) {
            hiddentext.clear();
            return;
        }
    }
    processKey() {
        if (keyCode >= 32 && keyCode <= 126) {
            hiddentext.input(key);
        }
    }
    setText(s) {
        this.currentText = s;
        this.graphics.clear();
        this.graphics.text(this.currentText, this.textPosition.x, this.textPosition.y);
    }
    overlapLetter(x, y) {
        return this.graphics.pixels[4 * (Math.floor(y) * Math.floor(this.graphics.width) + Math.floor(x)) + 3] > 240;
    }
    addNetwork(region) {
        const newNetwork = new ParticleNetwork(region);
        this.graphics.loadPixels();
        const xInterval = this.particleInterval;
        const yInterval = xInterval * cos(PI / 3);
        for (let row = 0, y = region.topPositionY; y < region.bottomPositionY; row += 1, y += yInterval) {
            for (let x = region.leftPositionX + (row % 2) * 0.5 * xInterval; x < region.rightPositionX; x += xInterval) {
                if (this.overlapLetter(x, y)) {
                    this.addNode(newNetwork, new ParticleNode(x, y, newNetwork.frameCounter));
                }
            }
        }
        this.networkArray.push(newNetwork);
        this.networkMap.set(region, newNetwork);
    }
    addNode(newNetwork, newNode) {
        newNetwork.nodes.array.sort((nodeA, nodeB) => {
            return (-distSq(newNode.basePosition, nodeA.basePosition)
                + distSq(newNode.basePosition, nodeB.basePosition));
        });
        let edgeCount = 0;
        for (let i = newNetwork.nodes.length - 1; i >= 0; i -= 1) {
            const otherNode = newNetwork.nodes.get(i);
            if (distSq(newNode.basePosition, otherNode.basePosition) < 800 &&
                this.overlapLetter(0.5 * (newNode.basePosition.x + otherNode.basePosition.x), 0.5 * (newNode.basePosition.y + otherNode.basePosition.y))) {
                newNetwork.addEdge(new ParticleEdge(newNode, otherNode));
                edgeCount += 1;
                if (edgeCount >= 5)
                    break;
            }
        }
        newNetwork.addNode(newNode);
    }
}


let networkArray;
let hiddentext;
let cursorShapeColor;
let backgroundColor;
// ---- Setup & Draw etc.
function setup() {
    createCanvas(windowWidth, windowHeight);
    updateCanvasScale();
    frameRate(IDEAL_FRAME_RATE);
    networkArray = new CleanableSpriteArray();
    hiddentext = new HiddenText(networkArray);
    cursorShapeColor = new ShapeColor(null, color(255));
    backgroundColor = color(0);
}
function draw() {
    scale(canvasScaleFactor);
    background(backgroundColor);
    networkArray.step();
    networkArray.clean();
    networkArray.draw();
    drawCursor();
}
function drawCursor() {
    if (frameCount % IDEAL_FRAME_RATE < 0.5 * IDEAL_FRAME_RATE) {
        cursorShapeColor.applyColor();
        rect(hiddentext.characterPosition.x, hiddentext.characterPosition.y, 5, hiddentext.textLeading);
    }
}
function keyPressed() {
    hiddentext.processKeyCode();
}
function keyTyped() {
    hiddentext.processKey();
}
